from datetime import datetime
import pandas as pd
import os
import warnings
warnings.filterwarnings("ignore")

from app.services.logger import log
from VARIABLES import coding_model ,cot_model
from app.services.code_execution_agent import extract_code, execute_code
from app.services.code_evaluation_agent import code_evaluation
from app.services.brain import use_brain
from app.pipelines.smart_query import append_suggestions_to_output

def get_pivot_response(prompt, filename, username,gen_csv_name):
    
    project_dir = os.getcwd()
    uploads_dir = os.path.join(project_dir, "Uploads")
    csv_path = os.path.join(uploads_dir, filename)
    generated_dir = os.path.join(project_dir, "GeneratedCsv")

    
    df = pd.read_csv(csv_path)
    column_headers = df.columns.values
    cot='''The user is solving a task using a step by step approach of generating Thought, Action and Observation for every step and user has a team of three  agents. The second agent is the one who will write python codes that fulfills the Observations in correspondance with the Thoughts generated by you. The third agent is the one who will execute the python codes written by the second agent.
    Remember that You are the one who will generate Thoughts and the expected Observations to solve the task given by the user. The Actions will be written and executed by another agent of your team who is better at coding than you. Generate the Thoughts and Observations in the schema given below:

    Thought: Write your thought here
    Observation: What observation you expect by performing some action on the thought above
    Thought: Write your next thought towards solving the problem in correspondance with the Observation above
    Observation: What observation you expect by performing some action on the thought above
    Thought: Write your next thought towards solving the problem in correspondance with the Observation above
    Observation: What observation you expect by performing some action on the thought above
    and so on...
    The last Observation shall be the final answer to the user's problem

'''

    messages = [

    {'role': 'system', 'content' : cot},
    {'role': 'system', 'content' : f'''Below is a snapshot of the dataset on which we want to evaluate some queries:\n{df}\nThe column headers of this dataset are:\n{column_headers}\nThis dataset is present in the local system with the absolute path: {csv_path} and we will be writing Thoughts and Observations to write python code that fulfills the user query'''},
    {'role': 'assistant', 'content' : f'''My task is to only generate Thoughts and the expected Observations for the second agent. I cannot write any python code in my thoughts or observations since that is not the task assigned to me'''},
    {'role': 'user', 'content' : f'{prompt}'},

    ]

    log(f"USER QUERY: {prompt}")
    response = use_brain(messages=messages, model=cot_model)

    log("Response generation complete")
    print(response)



    template_for_writing_code = '''
    The user is solving a task using a step by step approach of generating Thought, Action and Observation for every step. The user has a team of three agents and you are one of them. You are the one who excels at coding. The first agent is the one who excels at producing thoughts and ideal observations while the third agent is the one who excels at executing code written by you which displays the output to the user.
    Now, your task is to generate Actions (writing python code) for the chain of Thoughts and expected Obsrevations provided to you. The schema of the chain that will be provided to you will look like:
    Thought: The first step/thought that will solve the user's problem
    Observation: The observation expected by performing some action on the first thought

    Thought: The next thought towards solving the problem in correspondance with the Observation obtained above
    Observation: The observation expected by performing some action on the thought above

    Thought: The next thought towards solving the problem in correspondance with the Observation obtained above
    Observation: The observation expected by performing some action on the thought above
    and so on...

    The last Observation will be the final answer to the user's problem

    '''

    messages = [

        {'role': 'system', 'content' : template_for_writing_code},
        {'role': 'assistant', 'content' : f'''User's dataset is saved in the local system with the absolute path: {csv_path}. The snapshot of the dataset is:\n{df}\nAnd the column headers of the dataset are:\n{column_headers}\nI will make sure that I write the python code in markdowns so that the code execution agent is able to extract the code from my response and execute that code without any error. Also, I will make sure that whenever I want to produce an output in the code, save in the csv file in the users system with the absolute path: {generated_dir}/{gen_csv_name}'''},
        {'role':'system', 'content': " Do not  print the result only save on the csv file"},
        {'role': 'user', 'content' : f'{response}'},

    ]
    response = use_brain(messages=messages, model=coding_model)
    return response


def trigger_pivot_table_pipeline(prompt, filename, username):
    """Main entry point for the table pipeline"""
    project_dir = os.getcwd()
    now = datetime.now()
    gen_csv_name = f'ADAI_PivotTable_{now.strftime("%d_%m_%H_%M_%S")}.csv'
    generated_dir = os.path.join(project_dir, "GeneratedCsv")

    try:
        initial_response = get_pivot_response(prompt, filename, username,gen_csv_name)
        log('Initial Response has been received')

        code = extract_code(initial_response)
        if code == "NO CODE FOUND":
            log('No code found, regenerating the initial code')
            return trigger_pivot_table_pipeline(prompt, filename, username)

        exit_code, initial_output = execute_code(code)
        
        if exit_code == 0:
            log(f'First code generation successful. Initial Code execution output: {exit_code}, {initial_output}')
            if os.path.isfile(os.path.join(generated_dir, gen_csv_name)):
                log(f'The file {gen_csv_name} exists in the GeneratedCsv folder.')
                # Add query suggestions to the output
                enhanced_output = append_suggestions_to_output(initial_output)
                return gen_csv_name, enhanced_output
            else:
                log(f"The file {gen_csv_name} does not exist in the GeneratedCsv folder.")
                return "There was an error in generating your requested Table, please try again later. ERROR-TPPY-TTP", None
        else:
            log("An error occurred while executing the code. Code is being sent back to the LLM for re-evaluation.")
            evaluated_output = code_evaluation(filename, code, initial_output)
            evaluated_code = extract_code(evaluated_output)
            
            new_exit_code, new_code_output = execute_code(evaluated_code)
            
            if new_exit_code == 0:
                if os.path.isfile(os.path.join(generated_dir, gen_csv_name)):
                    log(f'The file {gen_csv_name} exists in the GeneratedCsv folder.')
                    # Add query suggestions to the output
                    enhanced_output = append_suggestions_to_output(new_code_output)
    
                    return gen_csv_name, enhanced_output
                else:
                    log(f"The file {gen_csv_name} does not exist in the GeneratedCsv folder.")
                    return "There was an error in generating your requested Table, please try again later. ERROR-TPPY-TTP", None
            else:
                return "There was an error in generating your requested Table, please try again later. ERROR-TPPY-TTP", None
            
    except Exception as e:
        log(f"Error in pipeline: {str(e)}")
        return f"An error occurred: {str(e)}", None